<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MyBlog</title>
  
  
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="http://albuswhite.github.io/blog/"/>
  <updated>2019-11-04T12:57:46.806Z</updated>
  <id>http://albuswhite.github.io/blog/</id>
  
  <author>
    <name>White Chen</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://albuswhite.github.io/blog/2019/11/04/advanced%20programming/"/>
    <id>http://albuswhite.github.io/blog/2019/11/04/advanced programming/</id>
    <published>2019-11-04T12:57:46.806Z</published>
    <updated>2019-11-04T12:57:46.806Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Week-1-2"><a href="#Week-1-2" class="headerlink" title="Week 1-2"></a>Week 1-2</h1><h2 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h2><h3 id="process-and-thread"><a href="#process-and-thread" class="headerlink" title="process and thread"></a>process and thread</h3><p>线程是进程中的⼀个实体，是被系统独⽴调度和分派的基本单位，线程⾃⼰不拥有系统资源，只拥有⼀点在运⾏中必不可少的资源，但它可与同属⼀个进程的其它线程共享进程所拥有的全部资 源。⼀个线程可以创建和撤消另⼀个线程，同⼀进程中的多个线程之间可以并发执⾏。线程有就 绪、阻塞和运⾏三种基本状态。</p><h4 id="Describe-the-TWO-main-differences-between-a-process-and-a-thread"><a href="#Describe-the-TWO-main-differences-between-a-process-and-a-thread" class="headerlink" title="Describe the TWO main differences between a process and a thread."></a>Describe the TWO main differences between a process and a thread.</h4><p>Difference 1<br>A process is isolated, has its own independent memory and it is associated with a single application; e.g. think of Window’s task manager.<br>All threads exist within one process and share the same memory</p><p>Difference 2<br>A thread can be thought of as a ‘light weight’ process; it is ususally used for small tasks.<br>Processes are used for more ‘heavy weight’ tasks; usually, to execute applications.</p><h3 id="States-and-Method"><a href="#States-and-Method" class="headerlink" title="States and Method"></a>States and Method</h3><p>ready-to-run, sleeping, waiting, running, blocked</p><p>run, yield, sleep, wait, notify, and notifyAll</p><h4 id="Relationship"><a href="#Relationship" class="headerlink" title="Relationship"></a>Relationship</h4><p>When a thread is constructed and the <strong>start( )</strong> method called, it is ready-to-run(but may not be running because it is waiting for a place on the CPU).</p><p>A thread is put to sleep by the <strong>sleep</strong> command, and afer the amout of time specified in the parameter it returns to ready-to-run state.</p><p>The <strong>yield</strong> command takes the thread in the running state and moves it to the ready-to-run state.</p><p>A thread can be moved to the waiting state by the <strong>wait</strong> command, and it returns to a ready-to-run state by the <strong>notify</strong> and <strong>notifyAll</strong> commands.</p><p>The <strong>run</strong> command operates on a thread in the ready-to-run state, and when it is finished the thread moves to the dead state.</p><h3 id="two-possible-ways-to-create-a-thread"><a href="#two-possible-ways-to-create-a-thread" class="headerlink" title="two possible ways to create a thread"></a>two possible ways to create a thread</h3><p>Method 1: Extend the Thread class<br>Method 2: Implement the Runnable interface<br>Generally developers recommend the implementing the Runnable interface, rather than the extending the Thread class.<br>This is because you can implement many interfaces, but you can only extend one class in Java.</p><h4 id="benefit-of-implementing-a-thread-using-the-Runnable-interface-rather-than-extending-the-Thread-class"><a href="#benefit-of-implementing-a-thread-using-the-Runnable-interface-rather-than-extending-the-Thread-class" class="headerlink" title="benefit of implementing a thread using the Runnable interface, rather than extending the Thread class?"></a>benefit of implementing a thread using the Runnable interface, rather than extending the Thread class?</h4><p>If you implement Runnable, the class will be able to extend another class.<br>If you extend Thread, you will not be able to extend any other class because Java only allows a class to extend one other class.</p><h3 id="Interrupt"><a href="#Interrupt" class="headerlink" title="Interrupt"></a>Interrupt</h3><h4 id="中断-interrupt"><a href="#中断-interrupt" class="headerlink" title="中断(interrupt)"></a>中断(interrupt)</h4><p>t.interrupt()不会中断正在执行的线程，只是将线程的标志位设置成true。但是如果线程在调用sleep(),join(),wait()方法时线程被中断，则这些方法会抛出InterruptedException，在catch块中捕获到这个异常时，线程的中断标志位已经被设置成false了，因此在此catch块中调用t.isInterrupted(),Thread.interrupted()始终都为false,<br>而t.isInterrupted与Thread.interrupted()的区别是:<br>Thread.interrupted()<br>检查是否发生中断.Thread.interrupted()能告诉你线程是否发生中断,并将清除中断状态标记，所以程序不会两次通知你线程发生了中断．<br>t.isInterrupted<br>测试线程是否已经中断。线程的中断状态不受该方法的影响。 </p><h4 id="What-is-interrupt-signal-How-is-an-interrupt-signal-represented-internally-in-the-Thread-class"><a href="#What-is-interrupt-signal-How-is-an-interrupt-signal-represented-internally-in-the-Thread-class" class="headerlink" title="What is interrupt signal? How is an interrupt signal represented internally in the Thread  class?"></a>What is interrupt signal? How is an interrupt signal represented internally in the Thread  class?</h4><p>An interrupt signal is a signal to a thread. to stop doing what it is doing.<br>It is represented as a <strong>Boolean</strong> variable.</p><h4 id="Four-ways-in-which-a-thread-can-be-terminated"><a href="#Four-ways-in-which-a-thread-can-be-terminated" class="headerlink" title="Four ways in which a thread can be terminated"></a>Four ways in which a thread can be terminated</h4><ol><li>In the catch statement, the interrupted( ) method could be called again to set the interrupt signal back to true. The thread would then naturally terminate.</li><li>The code could be changed so that the Interrupted Exception is caught by the GeneralInterrupt thread and this triggers an immediate return, terminating the thread.</li><li>The thread could be set to a daemon thread. It wil be automatically terminated by Java when the main thread completes.</li><li>Another Boolean variable could be used that be changed by other threads.</li></ol><h3 id="keyword"><a href="#keyword" class="headerlink" title="keyword"></a>keyword</h3><h4 id="Volatile"><a href="#Volatile" class="headerlink" title="Volatile"></a>Volatile</h4><p>Volatile is used to indicate that a variable’s value will be modified by different thread.<br>只有primitive variable 可以被声明为volatile,不适合复杂操作(意思是类,数组,借口这种变量不可被声明 )<br>e.g. public volatile int counter=0; 用法像final</p><h4 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h4><p>Synchronized means that <strong>getNextValue( )</strong> can only be access by one thread at a time (surrounds the method with a lock)<br>e.g. public synchronzied int getNextValue( ){ }<br>如果一个程序里有2个method 有 synchronized 关键词, 那么在同一时间只有1个被executed</p><h4 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h4><h5 id="Intrinsic-lock"><a href="#Intrinsic-lock" class="headerlink" title="Intrinsic lock"></a>Intrinsic lock</h5><p>when a thread has a lock, no other thread can acquire it.(It must wait for the first thread to release the lock)</p><h5 id="monitor-lock"><a href="#monitor-lock" class="headerlink" title="monitor lock"></a>monitor lock</h5><p>mutual exclusion(synchronized): only allows one thread to execute a part of code at a given time.<br>cooperation(wait( ) and notify( )): enable threads to work together.</p><h5 id="Deadlock"><a href="#Deadlock" class="headerlink" title="Deadlock"></a>Deadlock</h5><p>two or more threads waiting for two or more loclks to be freed, and the circumstances in the program is such that the locks will never be freed.</p><h4 id="Multithreading"><a href="#Multithreading" class="headerlink" title="Multithreading"></a>Multithreading</h4><p>The most common multithreading issues are Race Conditions and Deadlocks.</p><h5 id="race-condition"><a href="#race-condition" class="headerlink" title="race condition"></a>race condition</h5><p>A race condition occurs when two or more threads can access shared data and they try to change it at the same time, but you don’t know the order in which the threads will attempt to access the shared data.</p><h5 id="Briefly-describe-the-main-difficulties-faced-by-software-developers-when-producing-multithreaded-code"><a href="#Briefly-describe-the-main-difficulties-faced-by-software-developers-when-producing-multithreaded-code" class="headerlink" title="Briefly describe the main difficulties faced by software developers, when producing multithreaded code."></a>Briefly describe the main difficulties faced by software developers, when producing multithreaded code.</h5><p>With TCP, there is absolute guarantee that the data transferred remains intact and arrives in the same order in which it was sent<br>With UDP, there is no guarantee that the messages or packets sent would reach at all.</p><h4 id="critical-piece"><a href="#critical-piece" class="headerlink" title="critical piece"></a>critical piece</h4><p>A critical piece of code is one where two threads execute the code at the same time but the code is not thread-safe which can cause e.g, data to become unsynchronized.</p><h5 id="Indicate-the-Java-keyword-that-is-used-to-protect-a-critical-piece-of-code"><a href="#Indicate-the-Java-keyword-that-is-used-to-protect-a-critical-piece-of-code" class="headerlink" title="Indicate the Java keyword that is used to protect a critical piece of code."></a>Indicate the Java keyword that is used to protect a critical piece of code.</h5><p>The synchronized keyword is used to protect a critical piece of code.</p><h5 id="If-two-threads-attempt-to-access-a-critical-piece-of-code-one-of-the-threads-will-be-successful-and-execute-the-code-In-this-scenario-indicate-what-will-happen-to-the-second-thread"><a href="#If-two-threads-attempt-to-access-a-critical-piece-of-code-one-of-the-threads-will-be-successful-and-execute-the-code-In-this-scenario-indicate-what-will-happen-to-the-second-thread" class="headerlink" title="If two threads attempt to access a critical piece of code, one of the threads will be successful and execute the code. In this scenario, indicate what will happen to the second thread."></a>If two threads attempt to access a critical piece of code, one of the threads will be successful and execute the code. In this scenario, indicate what will happen to the second thread.</h5><p>In this scenario, the second thread will go into a blocked state.</p><h3 id="TCP-UDP"><a href="#TCP-UDP" class="headerlink" title="TCP/UDP"></a>TCP/UDP</h3><h4 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h4><h5 id="A-port-number-is-provided-when-setting-up-a-socket-connection-Valid-port-numbers-are-in-the-range-0–65536-but-you-should-not-use-ports-in-the-range-0–1024-Explain-why-that-is-the-case"><a href="#A-port-number-is-provided-when-setting-up-a-socket-connection-Valid-port-numbers-are-in-the-range-0–65536-but-you-should-not-use-ports-in-the-range-0–1024-Explain-why-that-is-the-case" class="headerlink" title="A port number is provided when setting up a socket connection. Valid port numbers are in the range 0–65536, but you should not use ports in the range 0–1024. Explain why that is the case."></a>A port number is provided when setting up a socket connection. Valid port numbers are in the range 0–65536, but you should not use ports in the range 0–1024. Explain why that is the case.</h5><p>Ports in the range 0-1024 are reserved ports and so should only be used for these established services</p><p>e.g.</p><ul>    <li> Web servers(HTTP) on port 80 </li>    <li> Encrypted web servers(HTTPS) on port 443 </li>    <li> Secure SHell(SSH) on port 22 </li>    <li> File Transfer Protocol(SMTP) on ports 20 and 21 </li>    <li> Simple Mail Transfer Protocol(SMTP) on port 25</li>    </ul><h5 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h5><ol><li><p>HTTPS is secure </p></li><li><p>HTTPS is the same as HTTP but runs over TLS </p></li><li><p>HTTPS uses port  443</p></li><li><p>All headers are encrypted</p></li><li><p>All payloads are encrypted</p></li></ol><h4 id="RMI"><a href="#RMI" class="headerlink" title="RMI"></a>RMI</h4><p>这个去年有考,但现在ppt上没有,先不写了.</p><h4 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h4><ol><li>The server instantiates a ServerSocket object, denoting which port number communication is to occur on.</li><li>The server invokes the accept() method of the ServerSocket class.</li><li>This method waits until a client connects to the server.</li><li>While the server is waiting, a client instantiates a Socket object, specifying the server name and the port number to connect to.</li><li>The constructor of the Socket class attempts to connect the client to the specified server and the port number. If communication is established, the client now has a Socket object capable of communicating with the server.</li><li>On the server side, the accept() method returns a reference to a new socket on the client that is connected to the client socket.</li></ol><h5 id="When-you-open-a-stream-you-should-always-close-it-when-you-have-finished-Briefly-explain-this-statement"><a href="#When-you-open-a-stream-you-should-always-close-it-when-you-have-finished-Briefly-explain-this-statement" class="headerlink" title="When you open a stream, you should always close it when you have finished. Briefly explain this statement."></a>When you open a stream, you should always close it when you have finished. Briefly explain this statement.</h5><p>In general, a stream is an expensive resource on a computer. This could be a stream over the internet, which is expensive to maintain, and these resources are limited and may prevent more connections</p><h5 id="Indicate-how-you-can-ensure-that-a-stream-is-always-closed-after-use-even-when-an-error-has-occurred"><a href="#Indicate-how-you-can-ensure-that-a-stream-is-always-closed-after-use-even-when-an-error-has-occurred" class="headerlink" title="Indicate how you can ensure that a stream is always closed after use, even when an error has occurred."></a>Indicate how you can ensure that a stream is always closed after use, even when an error has occurred.</h5><p>If an error occurs, you should surround it with a try-catch block, but you can also add any code you need in the event of an error and put it in a finally block.</p><h5 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h5><p>The <strong>ping</strong>  command sends 4 packets of data, in 32 types; it tells us:</p><ol><li>The IP address of the server that we are sending the ping command to.</li><li>The round trip time of each packet.</li><li>Other statistics, e.g. minimum and maximum times are average times.</li></ol><h2 id="Front-end"><a href="#Front-end" class="headerlink" title="Front end"></a>Front end</h2><h3 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h3><h4 id="常用标签"><a href="#常用标签" class="headerlink" title="常用标签"></a>常用标签</h4><p><img src="http://blog.albuswhite.com.cn/html%E4%BB%A3%E7%A0%81.png" alt="html常用代码"><br>列表 : 有序列表 <code>&lt;ol&gt; -- &lt;li&gt;</code><br>           无序列表 <code>&lt;ul&gt; -- &lt;li&gt;</code><br>表格: <code>&lt;table&gt;</code><br>标题  <code>&lt;th&gt;</code>       会出现加粗效果<br>行      <code>&lt;tr&gt;</code><br>列      <code>&lt;td&gt;</code></p><h4 id="Form"><a href="#Form" class="headerlink" title="Form"></a>Form</h4><p>这里把form单独拿出来讲下,因为这个东西没用且垃圾.但是喜欢考,历史的车轮滚滚向后.</p><figure class="highlight plain"><figcaption><span>onSubmit</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    First name: &lt;input type=&quot;text&quot; name=&quot;firstname&quot;&gt;&lt;br/&gt; </span><br><span class="line">    Last name : &lt;input type=&quot;text&quot; name=&quot;lastname&quot;&gt;&lt;br/&gt;&lt;br/&gt; </span><br><span class="line">    Preferred Username: &lt;input type=&quot;text&quot; name=&quot;user&quot;&gt;&lt;br/&gt; </span><br><span class="line">    Preferred Password: &lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;br/&gt; &lt;br/&gt; </span><br><span class="line">    Type of account to open:</span><br><span class="line"></span><br><span class="line">&lt;select name=&quot;accountType&quot;&gt;</span><br><span class="line">    &lt;option value=&quot;current&quot; selected=&quot;selected&quot;&gt;Current&lt;/option&gt; </span><br><span class="line">    &lt;option value=&quot;savings&quot;&gt;Savings&lt;/option&gt; </span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">    &lt;br/&gt;&lt;br/&gt; </span><br><span class="line">    &lt;input type=&quot;submit&quot; value=&quot;Submit&quot;&gt; </span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><p>这是上面那段代码的效果, 按下submit按钮,会使用post方法向createAccount.html发送函数onSubmitFullName()的结果<br><img src="http://blog.albuswhite.com.cn/form%E6%95%88%E6%9E%9C.png" alt="form效果"></p><h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h3><ol><li>The alert( ) function can be used to display text to the user in a web page.</li><li>A function is a reusable piece of JavaScript code that performs a common task.</li><li>var  is the JavaScript keyword used to create a variable.</li><li>In JavaScript, 3.14, 11 and 120 are examples of values of the number data type.</li><li>The JavaScript data type text is used to store characters and strings.</li><li>In JavaScript, we can use the parseInt( ) function to convert a string to an integer value.</li><li>An event handler is a command that JavaScript uses to deal with actions performed by the user while visiting a webpage; onChange and onClick are both examples of this.   </li></ol><h4 id="跳转页面"><a href="#跳转页面" class="headerlink" title="跳转页面"></a>跳转页面</h4><p>window.location.href = “votingSuccessful.html”;</p><h4 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h4><p>dom太复杂了,我也不知道从哪里讲起,暂时先列一下出现过的dom操作吧</p><ol><li><p><code>document.forms[&quot;filmVoting&quot;].fav_film.value;</code><br>这指的是叫做“filmVoting”的form其中name=“fav_film”那个标签的值.</p></li><li><p><code>document.bankForm.firstName.value</code><br>这个和上一个差不多,不过这个直接用了bankForm指向那个name=”bankForm”的form</p></li><li><p><code>document.write</code><br> 这个句子更傻逼了,就是在页面的最后加内容.</p></li></ol><h4 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h4><h5 id="使用-JavaScript-创建Cookie"><a href="#使用-JavaScript-创建Cookie" class="headerlink" title="使用 JavaScript 创建Cookie"></a>使用 JavaScript 创建Cookie</h5><p>document.cookie=”username=John Doe; expires= Thu, 18 Dec 2013 12:00:00 GMT; path=/“;</p><p>后面是过期时间和路径,暂时没看到有考</p><h5 id="使用-JavaScript-读取-Cookie"><a href="#使用-JavaScript-读取-Cookie" class="headerlink" title="使用 JavaScript 读取 Cookie"></a>使用 JavaScript 读取 Cookie</h5><p>var x=document.cookie;</p><h5 id="使用-JavaScript-修改-Cookie"><a href="#使用-JavaScript-修改-Cookie" class="headerlink" title="使用 JavaScript 修改 Cookie"></a>使用 JavaScript 修改 Cookie</h5><p>document.cookie=”username=John Doe; expires= Thu, 18 Dec 2013 12:00:00 GMT; path=/“;</p><p>其实就是覆盖</p><h5 id="使用-JavaScript-删除-Cookie"><a href="#使用-JavaScript-删除-Cookie" class="headerlink" title="使用 JavaScript 删除 Cookie"></a>使用 JavaScript 删除 Cookie</h5><p>document.cookie = “username=; expires=Thu, 01 Jan 1970 00:00:00 GMT”;</p><p>本质是把过期时间设置为过去.</p><p> 记录一下小测感想,只占3分问题不大.<br> 黑科技top1:找人帮忙签到,在寝室做小测<br> 其余找人问啊,现场百度啊都有点捞(看到一个小姐姐百度打开又关的,老师还就在她背后,我都尴尬)<br> 每个人考题不一样,考得比期末考细不少,以上.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Week-1-2&quot;&gt;&lt;a href=&quot;#Week-1-2&quot; class=&quot;headerlink&quot; title=&quot;Week 1-2&quot;&gt;&lt;/a&gt;Week 1-2&lt;/h1&gt;&lt;h2 id=&quot;Thread&quot;&gt;&lt;a href=&quot;#Thread&quot; class=&quot;headerli
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://albuswhite.github.io/blog/2019/11/04/Internet%20protocols/"/>
    <id>http://albuswhite.github.io/blog/2019/11/04/Internet protocols/</id>
    <published>2019-11-04T12:55:18.881Z</published>
    <updated>2019-11-04T12:55:18.881Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><h3 id="ISO-OSI"><a href="#ISO-OSI" class="headerlink" title="ISO/OSI"></a>ISO/OSI</h3><p> ISO = International Standards Office</p><p>OSI = Open Systems Interconnection</p><p>presentation: allow applications to interpret meaning of data, e.g., encryption, compression, machine-specific conventions</p><p> session: synchronization, checkpointing, recovery of data exchange </p><p> Internet stack “missing” these layers!<br> these services, if needed, must be implemented in application</p><ul><li>application (FTP,SMTP,HTTP)</li><li>presentation </li><li>session</li><li>transport (TCP,UDP)</li><li>network (IP, routing protocols)</li><li>data link (Ethernet, 802.l l l (WiFi), PPP, MAC)</li><li>physical (bits “on the wire”)</li></ul><p><img src="http://blog.albuswhite.com.cn/layer.png" alt="http://blog.albuswhite.com.cn/layer.png"></p><p>17-18 第一大题 a) 16-17第一大题</p><ol><li>This layer exists at end hosts and takes care of <strong>reliability</strong> (if any) by ensuring lost data is retransmitted and all data arrives reliably in order.     —&gt; TCP  —&gt; transport</li><li>This layer would be used by <strong>programmers</strong> to open and close sockets and to send data from one machine to another.       —&gt; application</li><li>This layer contains the routing protocols <strong>OSPF and RIP</strong>. —&gt; network</li><li>This layer would move data from somewhere in a subnetwork to another place in the <strong>same subnetwork</strong>.<pre><code>--&gt;data link layer</code></pre></li><li>This layer would move data across the network <strong>from the initial source machine to the final destination</strong> machine.            —-&gt; network layer</li><li>A coaxial cable(电缆)  is most associated with which layer of the ISO/OSI model  –&gt; physical</li><li>An <strong>IP</strong> (Internet protocol) address (such as 127.0.0.1) is most associated with which layer of the ISO/OSI model      —&gt; network</li><li>An <strong>MAC</strong> (Media Access Control) address (such as 54-8c-a0-df-90-81) is most associated with which layer of the ISO/OSI model    —&gt; data link</li><li>A *<em>router *</em>is most associated with which layer of the ISO/OSI model  —&gt; network</li><li>A <strong>switch</strong> is most associated with which layer of the ISO/OSI model  —&gt; data link</li><li>Which level of the ISO/OSI model ensures that data is sent to the correct <strong>host</strong> wherever it might be in the world  —&gt; network</li><li>Transmits bits over a <strong>medium</strong> using the electronic, optical or mechanical properties of that medium. <pre><code>---&gt;physical</code></pre></li></ol><p>16-17, 17-18 第一大题 b)+tutorial</p><h2 id="Transport-layer"><a href="#Transport-layer" class="headerlink" title="Transport layer"></a>Transport layer</h2><h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><p><img src="http://blog.albuswhite.com.cn/UDP.png" alt="http://blog.albuswhite.com.cn/UDP.png"></p><h4 id="UDP-checksum"><a href="#UDP-checksum" class="headerlink" title="UDP checksum"></a>UDP checksum</h4><h5 id="Goal"><a href="#Goal" class="headerlink" title="Goal"></a>Goal</h5><p>detect “errors” (e.g. flipped bits - 0 becomes 1 or 1 becomes 0 ) in transmitted segment </p><h5 id="sender"><a href="#sender" class="headerlink" title="sender"></a>sender</h5><ul><li>treat segment contents, including header fields, as sequence of 16-bits integers</li><li>checksum: addition(one’s complement sum of segment contents)</li><li>sender puts checksum value into UDP checksum field</li></ul><h5 id="receiver"><a href="#receiver" class="headerlink" title="receiver"></a>receiver</h5><ul><li>compute checksum of received segment</li><li>check if computed checksum equals checksum field value:<ul><li>NO - error detected</li><li>YES - no error detected. But maybe errors nonetheless? More later</li></ul></li></ul><p>17-18 第一题 C) 第二小题</p><h4 id="UDP-Encapsulation-decapsulation"><a href="#UDP-Encapsulation-decapsulation" class="headerlink" title="UDP Encapsulation/decapsulation"></a>UDP Encapsulation/decapsulation</h4><p><img src="http://blog.albuswhite.com.cn/UDP%20Encapsulation/decapsulation.png" alt="http://blog.albuswhite.com.cn/UDP%20Encapsulation/decapsulation.png"></p><p>17-18 第一大题 d)</p><h3 id="Multiplexing-demultiplexing"><a href="#Multiplexing-demultiplexing" class="headerlink" title="Multiplexing/demultiplexing"></a>Multiplexing/demultiplexing</h3><ol><li><p>Multiplexing: Combining several streams of data into a single stream.<br>multiplexing at sender:<br>handle data from multiple sockets, add transport header (later used for demultiplexing)</p></li><li><p>Demultiplexing: The opposite process. A stream of data is separated out into its individual components.<br>demultiplexing at receiver:<br>use header info to deliver received segments to correct socket</p></li><li><p>Full duplex means a link can send in both directions at the same time.</p></li><li><p>Simplex means a link can send in only one direction.</p></li><li><p>Half duplex means a link can send in both directions but not in both directions at the same time</p></li></ol><h4 id="How-demultiplexing-works"><a href="#How-demultiplexing-works" class="headerlink" title="How demultiplexing works"></a>How demultiplexing works</h4><ul><li><p>host receives IP datagrams</p><ul><li>each datagram has source IP address, destination IP 32 bits source port # dest port # address</li><li>each datagram carries one transport-layer segment</li><li>each segment has source, destination port number</li></ul></li><li><p>host uses IP addresses &amp; port numbers to direct segment to appropriate socket</p></li></ul><p>17-18 第一大题 C) 第一小题</p><h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><h4 id="TCP-header"><a href="#TCP-header" class="headerlink" title="TCP header"></a>TCP header</h4><p><img src="http://blog.albuswhite.com.cn/tcpheader.png" alt="http://blog.albuswhite.com.cn/tcpheader.png"></p><h5 id="Source-Destination-Port-Numbers"><a href="#Source-Destination-Port-Numbers" class="headerlink" title="Source / Destination Port Numbers"></a>Source / Destination Port Numbers</h5><p>Used to identify source and destination application instances.</p><h5 id="SYN-Flag"><a href="#SYN-Flag" class="headerlink" title="SYN Flag"></a>SYN Flag</h5><p>Used to signal the opening of a new TCP connection – 3-way handshake – causes Sum to be set at the receiver if connection accepted.</p><h5 id="Acknowledgement-Number"><a href="#Acknowledgement-Number" class="headerlink" title="Acknowledgement Number"></a>Acknowledgement Number</h5><p>Index value of the next byte expected in the ordered sequence of data to be received. By definition, all preceeding bytes must have been received to form a contigious stream up until this point.</p><h5 id="With-the-aid-of-diagrams-explain-how-TCP-maintains-the-transmission-as-a-connection-oriented-transport-layer-protocol"><a href="#With-the-aid-of-diagrams-explain-how-TCP-maintains-the-transmission-as-a-connection-oriented-transport-layer-protocol" class="headerlink" title="With the aid of diagrams, explain how TCP maintains the transmission as a connection-oriented transport layer protocol."></a>With the aid of diagrams, explain how TCP maintains the transmission as a connection-oriented transport layer protocol.</h5><p>TCP use three-way handshaking scheme to establish the bi-direction connection before transmitting data. While the termination process is carried out separately for two directions</p><p><img src="http://blog.albuswhite.com.cn/tcp1.png" alt="http://blog.albuswhite.com.cn/tcp1.png"></p><p><img src="http://blog.albuswhite.com.cn/tcp2.png" alt="http://blog.albuswhite.com.cn/tcp2.png"></p><h4 id="flow-control"><a href="#flow-control" class="headerlink" title="flow control"></a>flow control</h4><p>flow control: receiver controls sender, so sender will not overflow receiver buffer by transmitting too much, too fast  </p><h5 id="definition"><a href="#definition" class="headerlink" title="definition"></a>definition</h5><p>Flow control protocol is required to prevent data items being discarded at consumer when over pushing by the producer. It involves preventing senders from overrunning the capacity of the receivers.</p><p>Receiver controls the Send window size, and adjust its own Receive window, usually opening or closing to control the data flow</p><p><img src="http://blog.albuswhite.com.cn/tcpflow%20control.png" alt="http://blog.albuswhite.com.cn/tcpflow%20control.png"></p><ul><li>receiver “advertises” free buffer space by including rwnd value in TCP header of receiver-to-sender segments<ul><li>RcvBuffer size set via socket options (typical default is 4096 bytes)</li><li>many operating systems autoadjust RcvBuffer</li></ul></li><li>sender limits amount of unacked(“in-flight”) data to receiver’s rwnd value </li><li>guarantees receive buffer will not overflow</li></ul><p><img src="http://blog.albuswhite.com.cn/tcpcontrol2.png" alt="http://blog.albuswhite.com.cn/tcpcontrol2.png"></p><h5 id="Explain-how-flow-control-can-be-used-to-prevent-receive-buffer-overflow-using-a-Sliding-Window-approach"><a href="#Explain-how-flow-control-can-be-used-to-prevent-receive-buffer-overflow-using-a-Sliding-Window-approach" class="headerlink" title="Explain how flow control can be used to prevent receive buffer overflow using a Sliding Window approach."></a>Explain how flow control can be used to prevent receive buffer overflow using a Sliding Window approach.</h5><p>Rx tells Tx how much data to send - window (sent in Acks).</p><p>Rx can vary window size (increase or decrease)</p><p>Reduce window to 1: stop-and-wait or zero to halt flow</p><p>Other window sizes allow for progressive flow control that can easily adapt to the rate of application layer pull.</p><p>ACK from Rx contains SN for data to be acknowledged</p><p>Tx can send (W - u) packets: where W is window size for Tx and u is the number of packets outstanding</p><h4 id="congestion-control"><a href="#congestion-control" class="headerlink" title="congestion control"></a>congestion control</h4><p>Congestion control prevents too much data from being injected into the network, thereby causing switches or links to become overloaded</p><h5 id="AIMD"><a href="#AIMD" class="headerlink" title="AIMD"></a>AIMD</h5><p>additive increase multiplicative decrease</p><ul><li>approach: sender increases transmission rate(window size), probing for usable bandwidth, until loss occurs <ul><li>Set cwnd  congestion window to initial value</li><li>additive increase: increase cwnd by 1 MSS every RTT until loss detected</li><li>multiplicative decrease: cut cwnd in half after loss</li></ul></li></ul><h4 id="rdt"><a href="#rdt" class="headerlink" title="rdt"></a>rdt</h4><p>ACK = Acknowledgement is used to indicate that a message has been successfully received</p><p>RTS = Request to Send is used by a sender to ask for permission to send a message and reserve space on the channel</p><p>CTS = Clear to Send indicates the sender is allowed to send their message.</p><p>the correct order  in a successful CSMA/CA transmission</p><p>RTS, CTS, Data Transmission, ACK</p><h5 id="link-utilisation"><a href="#link-utilisation" class="headerlink" title="link utilisation"></a>link utilisation</h5><p>The proportion of the time that the link is used for sending data </p><p>U=(L/R) / (L/R + RTT)   </p><p>RTT(Round-Trip Time):往返时延</p><h2 id="Network-layer"><a href="#Network-layer" class="headerlink" title="Network layer"></a>Network layer</h2><h3 id="IP地址和子网划分"><a href="#IP地址和子网划分" class="headerlink" title="IP地址和子网划分"></a>IP地址和子网划分</h3><p>这部分基本搬运了<a href="https://blog.51cto.com/6930123/2112748" target="_blank" rel="noopener">https://blog.51cto.com/6930123/2112748</a>.</p><p>IP地址（Internet Protocol Address），缩写为IP Address，是一种在Internet上的给主机统一编址的地址格式，也称为网络协议（IP协议）地址。它为互联网上的每一个网络和每一台主机分配一个逻辑地址，常见的IP地址，分为IPv4与IPv6两大类，当前广泛应用的是IPv4，目前IPv4几乎耗尽，下一阶段必然会进行版本升级到IPv6；如无特别注明，一般我们讲的的IP地址所指的是IPv4。</p><blockquote><p>在计算机二进制中，1个字节 = 8位 = 8bit（比特）</p></blockquote><h4 id="IP地址格式和表示"><a href="#IP地址格式和表示" class="headerlink" title="IP地址格式和表示"></a>IP地址格式和表示</h4><p>IP地址(IPv4)由32位二进制数组成，分为4段（4个字节），每一段为8位二进制数（1个字节）<br>每一段8位二进制，中间使用英文的标点符号“.”隔开</p><p>由于二进制数太长，为了便于记忆和识别，把每一段8位二进制数转成十进制，大小为0至255。<br>IP地址的这种表示法叫做“点分十进制表示法”。<br>IP地址表示为：xxx.xxx.xxx.xxx<br>举个栗子：210.21.196.6就是一个IP地址的表示。</p><h4 id="IP地址的组成"><a href="#IP地址的组成" class="headerlink" title="IP地址的组成"></a>IP地址的组成</h4><p>IP地址=网络地址+主机地址，比如：192.168.1.100</p><p>计算机的IP地址由两部分组成，一部分为网络标识，一部分为主机标识，同一网段内的计算机网络部分相同，主机部分不同同时重复出现。路由器连接不同网段，负责不同网段之间的数据转发，交换机连接的是同一网段的计算机。通过设置网络地址和主机地址，在互相连接的整个网络中保证每台主机的IP地址不会互相重叠，即IP地址具有了唯一性。</p><h4 id="IP地址分类"><a href="#IP地址分类" class="headerlink" title="IP地址分类"></a>IP地址分类</h4><h5 id="A类地址"><a href="#A类地址" class="headerlink" title="A类地址"></a>A类地址</h5><ol><li>A类地址第1字节为网络地址（最高位固定是0），另外3个字节为主机地址。</li><li>A类地址范围：1.0.0.0 - 126.255.255.255，其中0和127作为特殊地址。</li><li>A类网络默认子网掩码为255.0.0.0，也可写作/8。</li><li>A类网络最大主机数量是256×256×256-2=166777214（减去1个主机位为0的网络地址和1个广播地址).</li></ol><blockquote><p>在计算机网络中，主机ID全部为0的地址为网络地址，而主机ID全部为1的地址为广播地址，这2个地址是不能分配给主机用的。</p></blockquote><h5 id="B类地址"><a href="#B类地址" class="headerlink" title="B类地址"></a>B类地址</h5><ol><li>B类地址第1字节（最高位固定是10）和第2字节为网络地址，另外2个字节为主机地址。</li><li>B类地址范围：128.0.0.0 - 191.255.255.255。</li><li>B类网络默认子网掩码为255.255.0.0，也可写作/16。</li><li>B类网络最大主机数量256×256-2=6554。</li></ol><h5 id="C类地址"><a href="#C类地址" class="headerlink" title="C类地址"></a>C类地址</h5><ol><li>C类地址第1字节（最高位固定是110）、第2字节和第3个字节，另外1个字节为主机地址。</li><li>C类地址范围：192.0.0.0 - 223.255.255.255。</li><li>C类网络默认子网掩码为255.255.255.0，也可写作/24。</li><li>C类网络最大主机数量256-2=254。</li></ol><h5 id="D类地址"><a href="#D类地址" class="headerlink" title="D类地址"></a>D类地址</h5><ol><li>D类地址不分网络地址和主机地址，它的第1个字节的最高位固定是1110。</li><li>D类地址用于组播（也称为多播）的地址，无子网掩码。</li><li>D类地址范围：224.0.0.0 - 239.255.255.255。</li></ol><h5 id="E类地址"><a href="#E类地址" class="headerlink" title="E类地址"></a>E类地址</h5><ol><li>E类地址也不分网络地址和主机地址，它的第1个字节的最高位固定是11110。</li><li>E类地址范围：240.0.0.0 - 255.255.255.255。</li><li>其中240.0.0.0-255.255.255.254作为保留地址，主要用于Internet试验和开发，255.255.255.255作为广播地址。</li></ol><p><img src="http://blog.albuswhite.com.cn/IP.png" alt="http://blog.albuswhite.com.cn/IP.png"></p><h4 id="保留的特殊IP地址"><a href="#保留的特殊IP地址" class="headerlink" title="保留的特殊IP地址"></a>保留的特殊IP地址</h4><p>以下这些特殊IP地址都是不能分配给主机用的地址：</p><ul><li>主机ID全为0的地址：特指某个网段，比如：192.168.10.0 255.255.255.0，指192.168.10.0网段。</li><li>主机ID全为1的地址：特指该网段的全部主机，比如：192.168.10.255，如果你的计算机发送数据包使用主机ID全是1的IP地址，数据链层地址用广播地址FF-FF-FF-FF-FF-FF。</li><li>127.0.0.1：是本地环回地址，指本机地址，一般用来测试使用。回送地址(127.x.x.x)是本机回送地址(Loopback Address)，即主机IP堆栈内部的IP地址。</li><li>169.254.0.0：169.254.0.0-169.254.255.255实际上是自动私有IP地址。</li><li>0.0.0.0：如果计算机的IP地址和网络中的其他计算机地址冲突，使用ipconfig命令看到的就是0.0.0.0，子网掩码也是0.0.0.0。</li></ul><p><img src="http://blog.albuswhite.com.cn/IP%E4%BF%9D%E7%95%99%E5%9C%B0%E5%9D%80.png" alt="http://blog.albuswhite.com.cn/IP%E4%BF%9D%E7%95%99%E5%9C%B0%E5%9D%80.png"></p><h4 id="公网和私网IP地址"><a href="#公网和私网IP地址" class="headerlink" title="公网和私网IP地址"></a>公网和私网IP地址</h4><p>公网IP地址<br>公有地址分配和管理由Inter NIC（Internet Network Information Center 因特网信息中心）负责。各级ISP使用的公网地址都需要向Inter NIC提出申请，有Inter NIC统一发放，这样就能确保地址块不冲突。</p><p>私网IP地址<br>创建IP寻址方案的人也创建了私网IP地址。这些地址可以被用于私有网络，在Internet没有这些IP地址，Internet上的路由器也没有到私有网络的路由表。</p><p>A类：10.0.0.0 255.0.0.0，保留了1个A类网络。<br>B类：172.16.0.0 255.255.0.0～172.31.0.0 255.255.0.0，保留了16个B类网络。<br>C类：192.168.0.0 255.255.255.0～192.168.255.0 255.255.255.0，保留了256个C类网络。</p><p><img src="http://blog.albuswhite.com.cn/%E7%A7%81%E7%BD%91.png" alt="http://blog.albuswhite.com.cn/%E7%A7%81%E7%BD%91.png"></p><h4 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h4><blockquote><p>IP地址是以网络号和主机号来标示网络上的主机的，我们把网络号相同的主机称之为本地网络，网络号不相同的主机称之为远程网络主机，本地网络中的主机可以直接相互通信；远程网络中的主机要相互通信必须通过本地网关（Gateway）来传递转发数据。</p></blockquote><h5 id="子网掩码的概念及作用"><a href="#子网掩码的概念及作用" class="headerlink" title="子网掩码的概念及作用"></a>子网掩码的概念及作用</h5><ol><li>子网掩码（Subnet Mask）又叫网络掩码、地址掩码，必须结合IP地址一起对应使用。</li><li>只有通过子网掩码，才能表明一台主机所在的子网与其他子网的关系，使网络正常工作。</li><li>子网掩码和IP地址做“与”运算，分离出IP地址中的网络地址和主机地址，用于判断该IP地址是在本地网络上，还是在远程网络网上。</li><li>子网掩码还用于将网络进一步划分为若干子网，以避免主机过多而拥堵或过少而IP浪费。</li></ol><p><img src="http://blog.albuswhite.com.cn/%E6%8E%A9%E7%A0%81e.g..png" alt="http://blog.albuswhite.com.cn/%E6%8E%A9%E7%A0%81e.g..png"></p><h5 id="子网掩码的组成"><a href="#子网掩码的组成" class="headerlink" title="子网掩码的组成"></a>子网掩码的组成</h5><ol><li>同IP地址一样，子网掩码是由长度为32位二进制数组成的一个地址。</li><li>子网掩码32位与IP地址32位相对应，IP地址如果某位是网络地址，则子网掩码为1，否则为0。</li><li>举个栗子：如：11111111.11111111.11111111.00000000<blockquote><p>注：左边连续的1的个数代表网络号的长度，（使用时必须是连续的，理论上也可以不连续），右边连续的0的个数代表主机号的长度。</p></blockquote></li></ol><h5 id="子网掩码的表示方法"><a href="#子网掩码的表示方法" class="headerlink" title="子网掩码的表示方法"></a>子网掩码的表示方法</h5><ol><li><p>点分十进制表示法<br>二进制转换十进制，每8位用点号隔开<br>例如：子网掩码二进制11111111.11111111.11111111.00000000，表示为255.255.255.0</p></li><li><p>CIDR斜线记法<br>IP地址/n<br>例1：192.168.1.100/24，其子网掩码表示为255.255.255.0，二进制表示为11111111.11111111.11111111.00000000</p></li></ol><p>例2：172.16.198.12/20，其子网掩码表示为255.255.240.0，二进制表示为11111111.11111111.11110000.00000000</p><p>不难发现，例1中共有24个１，例2中共有20个１，所以n是这么来的。运营商ISP常用这样的方法给客户分配IP地址。</p><blockquote><p>注：n为1到32的数字，表示子网掩码中网络号的长度，通过n的个数确定子网的主机数=2^(32-n)-2（-2的原因：主机位全为0时表示本网络的网络地址，主机位全为1时表示本网络的广播地址，这是两个特殊地址）。</p></blockquote><h5 id="为什么要使用子网掩码？"><a href="#为什么要使用子网掩码？" class="headerlink" title="为什么要使用子网掩码？"></a>为什么要使用子网掩码？</h5><p>前面说道，子网掩码可以分离出IP地址中的网络地址和主机地址，那为什么要分离呢？因为两台主机要通信，首先要判断是否处于同一网段，即网络地址是否相同。如果相同，那么可以把数据包直接发送到目标主机，否则就需要路由网关将数据包转发送到目的地。</p><h5 id="子网掩码的分类"><a href="#子网掩码的分类" class="headerlink" title="子网掩码的分类"></a>子网掩码的分类</h5><p><strong>1. 缺省子网掩码</strong></p><p>也叫默认子网掩码，即未划分子网，对应的网络号的位都置 1 ，主机号都置 0 。</p><p>未做子网划分的IP地址：网络号＋主机号</p><p>A类网络缺省子网掩码： 255.0.0.0，用CIDR表示为/8</p><p>B类网络缺省子网掩码： 255.255.0.0，用CIDR表示为/16</p><p>C类网络缺省子网掩码： 255.255.255.0，用CIDR表示为/24</p><p><strong>2. 自定义子网掩码</strong></p><p>将一个网络划分子网后，把原本的主机号位置的一部分给了子网号，余下的才是给了子网的主机号。其形式如下：</p><p>做子网划分后的IP地址：网络号＋子网号＋子网主机号</p><p>举个栗子：</p><p>如：192.168.1.100/25，其子网掩码表示：255.255.255.128</p><p>意思就是将192.168.1.0这个网段的主机位的最高1位划分为了子网。关于子网划分将在下面讲到，这里不在阐述。</p><h5 id="子网掩码和IP地址的关系"><a href="#子网掩码和IP地址的关系" class="headerlink" title="子网掩码和IP地址的关系"></a>子网掩码和IP地址的关系</h5><p>子网掩码是用来判断任意两台主机的IP地址是否属于同一网络的依据，就是拿双方主机的IP地址和自己主机的子网掩码做与运算，如结果为同一网络，就可以直接通信。</p><blockquote><p>And按位与运算：<br>与运算是计算机中一种基本的逻辑运算方式，符号表示为&amp;，也可以表示为 and。<br>参加运算的两个数据，按二进制位进行“与”运算。<br>运算规则：0&amp;0=0；0&amp;1=0；1&amp;0=0；1&amp;1=1；<br>即：两位同时为“1”，结果才为“1”，否则为0</p></blockquote><p>如何根据IP地址和子网掩码，计算网络地址：</p><ol><li>将IP地址与子网掩码转换成二进制数。</li><li>将二进制形式的 IP 地址与子网掩码做“与”运算。</li><li>将得出的结果转化为十进制，便得到网络地址。<br>如下图：<br><img src="http://blog.albuswhite.com.cn/IP%E8%AE%A1%E7%AE%97.png" alt="http://blog.albuswhite.com.cn/IP%E8%AE%A1%E7%AE%97.png"></li></ol><blockquote><p>网络地址计算小技巧：IP地址和子网掩码做与运算，把IP地址的主机位直接归0，就快速得到网络地址。所以只要一看到IP地址和子网掩码，就能马上确认网络地址。</p></blockquote><h4 id="子网划分"><a href="#子网划分" class="headerlink" title="子网划分"></a>子网划分</h4><ol><li>为什么要划分子网？</li></ol><p>IPv4地址如果只使用有类（A、B、C类）来划分，会造成大量的浪费或者不够用，为了解决这个问题，可以在有类网络的基础上，通过对IP地址的主机号进行再划分，把一部分划入网络号，就能划分各种类型大小的网络了。</p><ol start="2"><li>IPv4子网划分与聚合</li></ol><p>为了解决IPv4的不足，提高网络划分的灵活性，诞生了两种非常重要的技术，那就是VLSM（可变长子网掩码）和CIDR（无类别域间路由），把传统标准的IPv4有类网络演变成一个更为高效，更为实用的无类网络。关于VLSM和CIDR的介绍参考上篇子网掩码详解有讲述。</p><p>VLSM用于IPv4子网的划分，也就是把一个大的网络划分成多个小的子网；而CIDR则用于IPv4子网的聚合，当然主要是指路由方面的聚合，也就是路由汇总。通过CIDR可以把多个小的子网路由条目汇总成一个大网络的路由条目，以减少路由器中路由条目的数量，提高路由效率</p><h5 id="子网划分方法"><a href="#子网划分方法" class="headerlink" title="子网划分方法"></a>子网划分方法</h5><p>我们所讲的子网划分其实就是基于VLSM可变长子网掩码的划分，子网划分又分为等长子网划分和变长子网划分。<br>通过VLSM实现子网划分的基本思想很简单：就是借用现有网段的主机位的最左边某几位作为子网位，划分出多个子网。</p><ol><li><p>把原来有类网络IPv4地址中的“网络ID”部分向“主机ID”部分借位</p></li><li><p>把一部分原来属于“主机ID”部分的位变成“网络ID”的一部分（通常称之为“子网ID”）。</p></li><li><p>原来的“网络ID”+“子网ID”=新“网络ID”。“子网ID”的长度决定了可以划分子网的数量。</p></li></ol><h5 id="等长子网和变长子网划分"><a href="#等长子网和变长子网划分" class="headerlink" title="等长子网和变长子网划分"></a>等长子网和变长子网划分</h5><p>子网划分的任务包括：</p><p>1、确定子网掩码的长度。</p><p>2、确定子网下的主机可用地址范围（第一个可用IP和最后一个可用IP）。</p><p>3、确定网络地址（主机位全为0）和广播地址（主机位全为1），不能分配计算机主机用。</p><p>Ⅰ、等长子网划分</p><p>等长子网划分就是将一个有类网络等分成多个网络，也就是等分成多个子网，所有子网的子网掩码都相同。</p><p>1、C类网络子网划分示例</p><p>①、等分为两个子网</p><p>将192.168.0.0 255.255.255.0这个网络等分成2个子网，并写出每个子网的地址信息？</p><p>分析：</p><p>该网络子网掩码为/24，要划分为2个子网，要借用主机位1位作为子网位。</p><p>因为二进制数0和1按一位排列组合，只有这2种，分别为：0，1，如下图所示。</p><p>0是A子网<br>1是B子网</p><p>借用主机1位，所以子网掩码+1位，由原来的255.255.255.0 （/24）变为255.255.255.128（/25）</p><p>结论：C类网络等分成2个子网，子网掩码往右移动1位，就能等分成2个子网，即2^1。<br><img src="http://blog.albuswhite.com.cn/C-1.png" alt="http://blog.albuswhite.com.cn/C-1.png"><br><img src="http://blog.albuswhite.com.cn/C-2.png" alt="http://blog.albuswhite.com.cn/C-2.png"></p><p>最终结果：</p><p>A子网的网络地址：192.168.0.0/25，可用地址（192.168.0.1～192.168.0.126），广播地址：192.168.0.127。</p><p>B子网的网络地址：192.168.0.128/25，可用地址（192.168.0.129～192.168.0.254），广播地址：192.168.0.255。</p><hr><p>②、等分为四个子网</p><p>同样将192.168.0.0 255.255.255.0 这个网络等分成4个子网</p><p>分析：要想分成4个子网，需要将子网掩码往右移动两位</p><p>这样第1位和第2位就变为网络位，就可以分成4个子网</p><p>因为二进制数0和1按两位排列组合，只有这4种，分别为：00，01，10，11，如下图所示。</p><p>00是A子网<br>01是B子网<br>10是C子网<br>11是D子网</p><p>借用主机2位，所以子网掩码+2位，由原来的255.255.255.0 （/24）变为255.255.255.192 （/26）</p><p>结论：C类网络等分成4个子网，子网掩码往右移动2位，就能等分成4个子网，即2^2。</p><p><img src="http://blog.albuswhite.com.cn/C-3.png" alt="http://blog.albuswhite.com.cn/C-3.png"><br><img src="http://blog.albuswhite.com.cn/C-4.png" alt="http://blog.albuswhite.com.cn/C-4.png"></p><p>最终结果：</p><p>A子网的网络地址：192.168.0.0/26，可用地址（192.168.0.1～192.168.0.62），广播地址：192.168.0.63/26。</p><p>B子网的网络地址：192.168.0.64/26，可用地址（192.168.65～192.168.0.126），广播地址：192.168.0.127。</p><p>C子网的网络地址：192.168.0.128/26，可用地址（192.168.129～192.168.0.190），广播地址：192.168.0.191。</p><p>D子网的网络地址：192.168.0.192/26，可用地址（192.168.193/26～192.168.0.254），广播地址：192.168.0.255。</p><hr><p>2、B类网络子网划分示例</p><p>将131.107.0.0/16等分成2个子网，写出各个子网的第一个和最后一个可用的IP地址？</p><p>分析：要划分为2个子网，就要借用主机位1位作为子网位。</p><p>0是A子网<br>1是B子网</p><p>借用主机1位，所以子网掩码+1位，由原来的255.255.0.0 （/16）变为255.255.128.0（/17）</p><p>结论：B类网络等分成2个子网，子网掩码往右移动1位，就能等分成2个子网，即2^1。</p><p>最终结果：</p><p>A子网<br>网络地址：131.107.0.0/17，<br>可用地址（131.107.0.1 ~ 131.107.127.254）<br>广播地址：131.107.127.255</p><p>B子网<br>网络地址：131.107.128.0/17<br>可用地址（131.107.128.1 ~ 131.107.255.254）<br>广播地址：131.107.255.255<br><img src="http://blog.albuswhite.com.cn/B-1.png" alt="http://blog.albuswhite.com.cn/B-1.png"></p><p>3、A类网络子网划分示例</p><p>将A类网络42.0.0.0/8等分成4个子网，写出各个子网的第一个和最后一个可用的IP地址？</p><p>分析：要划分为4个子网，就要借用主机位2位作为子网位</p><p>00是A子网<br>01是B子网<br>10是C子网<br>11是D子网</p><p>借用主机2位，所以子网掩码+2位，由原来的255.0.0.0 （/8）变为255.192.0.0（/10）</p><p>结论：A类网络等分成4个子网，子网掩码往右移动2位，就能等分成4个子网，即2^2。</p><p>最终结果：</p><p>A子网的网络地址：40.0.0.0/10，可用地址（40.0.0.1 ~ 40.63.255.254），广播地址：40.63.255.255</p><p>B子网的网络地址：40.64.0.0/10，可用地址（40.64.0.1 ~ 40.127.255.254），广播地址：40.127.255.255</p><p>C子网的网络地址：40.128.0.0/10，可用地址（40.128.0.1 ~ 40.191.255.254），广播地址：40.191.255.255</p><p>D子网的网络地址：40.192.0.0/10，可用地址（40.192.0.1 ~ 40.255.255.254），广播地址：40.255.255.255<br><img src="http://blog.albuswhite.com.cn/C-1.png" alt="http://blog.albuswhite.com.cn/C-1.png"></p><p>Ⅱ、变长子网划分</p><p>VLSM规定了如何在一个进行了子网划分的网络中，不同子网使用不同的子网掩码。这对于网络内部不同网段需要不同大小子网的情形来说很有效，这种划分子网的方式叫变长子网划分。</p><p>变长子网划分其实就是在等长子网的划分上，分别取不同等分子网中的某个或者多个子网。</p><p>1、变长子网划分示例</p><p>INTRO<br>现要将一C类网段地址192.168.18.0/24分成三个子网（主机数为80,50,24）及10台公用办公设备（第四个子网）。<br>若按固定子网掩码的方式来划分该C类IP地址，要将该IP划分成4个子网，需要使用8位主机号的三位（可划分2^3-2=6个子网），剩下的5位主机号最多只能容纳2^5-2=30台主机，不满足要求。需用VLSM解决，具体过程如下：<br>STEPS<br>(1) 对于80台主机的子网，需要2^7-2=126，7位主机位（6位主机位只有62台主机），故将192.168.18.0/24划分成两个一级子网192.168.18.0/25及192.168.18.128/25，并将一个子网192.168.18.0/25划分给80台主机用;</p><p>(2) 对于50台主机的子网，需要6位主机位，将192.168.18.128/25的7位主机位拿出一位划分成两个二级子网192.168.18.128/26及192.168.18.192/26，并将一个二级子网192.168.18.128/26分配给50台主机用；</p><p>(3) 以此类推，划分三级子网192.168.18.192/27及192.168.18.224/27分别分配给24台主机及10台公用设备用<br>Done<br>最终结果如下：<br>    192.168.18.0/24-&gt;<br>    193.192.168.18.0/25 （80台主机）     -&gt;192.168.18.128/25<br>    192.168.18.128/26  (50台主机)            -&gt;192.168.18.192/26<br>    193.192.168.18.192/27 (24台主机)      -&gt;192.168.18.224/27（10台公用设备）</p><p>2、变长子网划分总结</p><p>①、变长子网划分规律</p><p>如果一个子网地址块是原来网段的(1/2)^n，子网掩码就在原网段的基础上右移n位，不等长子网，子网掩码也不同。</p><p>②、点到点网络的子网掩码</p><p>每个子网是原来网络的(1/2)×(1/2)×(1/2)×(1/2)×(1/2)×(1/2)，也就是(1/2)^6，子网掩码往右移动6位。</p><p>例如：11111111.11111111.11111111.11111100写成十进制子网掩码也就是255.255.255.252。</p><h4 id="子网划分总结和技巧"><a href="#子网划分总结和技巧" class="headerlink" title="子网划分总结和技巧"></a>子网划分总结和技巧</h4><p><img src="http://blog.albuswhite.com.cn/%E8%A1%A8.png" alt="http://blog.albuswhite.com.cn/%E8%A1%A8.png"></p><p>1、确定划分子网数</p><p>子网数 = 2^n，n代表子网掩码往右移动的位数<br>例如：<br>要划分2个子网，子网掩码需要往右移动1位，2^1=2<br>要划分4个子网，子网掩码需要往右移动2位，2^2=4<br>要划分8个子网，子网掩码需要往右移动3位，2^3=8<br>……<br>子网数只能为2倍的关系划分。</p><p>2、确定子网划分后的地址</p><p>每个子网地址块大小（IP_block）= 2^(8-n)<br>每个子网可用地址个数（IP_num）= 2^(8-n)-2<br>①、子网的网络地址 = 从0到255，取每段地址块的首个值<br>②、子网的广播地址 = 下一个子网的网络地址-1<br>③、子网的可用地址 = 子网的网络地址到子网的广播地址区间</p><p>例如：<br>要划分为4个网段（2^2），子网掩码右移2位<br>每个子网地址块大小（IP_block）= 2^(8-4) = 64<br>每个子网可用地址个数（IP_num）= 2^(8-4)-2 = 62<br>每段取值分别为：0，64，128，192<br>第一个子网<br>①、网络地址 = 0<br>②、广播地址 = 63<br>③、可用地址 = 1到62</p><p>第二个子网<br>①、网络地址 = 64<br>②、广播地址 = 127<br>③、可用地址 = 65到126</p><p>第三个子网<br>①、网络地址 = 128<br>②、广播地址 = 191<br>③、可用地址 = 129到190</p><p>第四个子网<br>①、网络地址 = 192<br>②、广播地址 = 255<br>③、可用地址 = 193到254</p><p>3、确定子网掩码</p><p>划分后的子网掩码CIDR = 原网络的子网掩码CIDR+n，如要写成十进制：256-2^(8-n)<br>例如：<br>原来子网掩码：255.255.255.0（/24），往右移动3位，则划分为8个子网<br>子网掩码就变为为 /27，256-2^(8-3) = 256-2^5 = 256-32 = 224<br>最后子网掩码结果：255.255.255.224（/27）</p><h3 id="sample-question"><a href="#sample-question" class="headerlink" title="sample question"></a>sample question</h3><ol><li>Identify the IP class of a host with IPv4 address 227.34.78.1. Calculate all the subnetwork addresses of 227.34.78.0/26</li></ol><p>Class D</p><p>Network address: 227.34.78.0/26 </p><p>Subnetwork address: 227.34.78.64/26 </p><p>Subnetwork address: 227.34.78.128/26 </p><p>Subnetwork address: 227.34.78.192/26 </p><p>到这week1-2 暂时只弄了17和16两张考试卷,有空再补</p><h2 id="Data-link-layer"><a href="#Data-link-layer" class="headerlink" title="Data link layer"></a>Data link layer</h2><h3 id="MAC-地址"><a href="#MAC-地址" class="headerlink" title="MAC 地址"></a>MAC 地址</h3><p>MAC（Media Access Control，介质访问控制）地址，或称为物理地址，也叫硬件地址，用来定义网络设备的位置，MAC地址是网卡出厂时设定的，是固定的（但可以通过在设备管理器中或注册表等方式修改，同一网段内的MAC地址必须唯一）。MAC地址采用十六进制数表示，长度是6个字节（48位），分为前24位和后24位。</p><blockquote><p> 1、前24位叫做组织唯一标志符（Organizationally Unique Identifier，即OUI），是由IEEE的注册管理机构给同厂家分配的代码，区分了不同的厂家。<br> 2、后24位是由厂家自己分配的，称为扩展标识符。同一个厂家生产的网卡中MAC地址后24位是不同的。</p></blockquote><p>   MAC地址对应于OSI参考模型的第二层数据链路层，工作在数据链路层的交换机维护着计算机MAC地址和自身端口的数据库，交换机根据收到的数据帧中的“目的MAC地址”字段来转发数据帧。</p><h3 id="IP地址与MAC地址区别"><a href="#IP地址与MAC地址区别" class="headerlink" title="IP地址与MAC地址区别"></a>IP地址与MAC地址区别</h3><ul><li>长度不同：IP地址为32位（二进制），MAC地址为48位（十六进制）。</li><li>分配依据不同：IP地址的分配是基于网络拓扑，MAC地址的分配是基于制造商。</li><li>寻址协议层不同：IP地址应用于OSI第三层（网络层），而MAC地址应用在OSI第二层（数据链路层）。</li></ul><h3 id="IP地址与MAC地址的作用和关系"><a href="#IP地址与MAC地址的作用和关系" class="headerlink" title="IP地址与MAC地址的作用和关系"></a>IP地址与MAC地址的作用和关系</h3><p>IP和MAC两者之间分工明确，默契合作，完成通信过程。在数据通信时，IP地址专注于网络层，网络层设备（如路由器）根据IP地址，将数据包从一个网络传递转发到另外一个网络上；而MAC地址专注于数据链路层，数据链路层设备（如交换机）根据MAC地址，将一个数据帧从一个节点传送到相同链路的另一个节点上。IP和MAC地址这种映射关系由ARP（Address Resolution Protocol，地址解析协议）协议完成，ARP根据目的IP地址，找到中间节点的MAC地址，通过中间节点传送，从而最终到达目的网络。</p><blockquote><p>计算机在和其他计算机通信之前，首先要判断目标IP地址和自己的IP地址是否在一个网段，这决定了数据链层的目标MAC地址是目标计算机的还是路由器接口的MAC地址。数据包的目标IP地址决定了数据包最终到达哪一个计算机，而目标MAC地址决定了该数据包下一跳由哪个设备接收，不一定是终点。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h2&gt;&lt;h3 id=&quot;ISO-OSI&quot;&gt;&lt;a href=&quot;#ISO-OS
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Verbal1</title>
    <link href="http://albuswhite.github.io/blog/2019/11/04/Verbal1/"/>
    <id>http://albuswhite.github.io/blog/2019/11/04/Verbal1/</id>
    <published>2019-11-04T12:51:49.034Z</published>
    <updated>2019-10-10T09:59:00.151Z</updated>
    
    <content type="html"><![CDATA[<h4 id="GRE填空常见观点"><a href="#GRE填空常见观点" class="headerlink" title="GRE填空常见观点"></a>GRE填空常见观点</h4><p>(1). 科学实验要客观，公正，可重复，可更正<br>(2). 专利法没有促进创新<br>(3). 物种入侵的危害不大/被夸大<br>(4). 工会(labor union)与资本家(business owner/ management)为敌对关系</p> <a id="more"></a><h4 id="GRE单词归类"><a href="#GRE单词归类" class="headerlink" title="GRE单词归类"></a>GRE单词归类</h4><h5 id="任性多变的"><a href="#任性多变的" class="headerlink" title="任性多变的"></a>任性多变的</h5><p>capricious = inconstant = volatile = mercurial= fickle = flighty = vagarious = wayward</p><h5 id="全面的，详尽的"><a href="#全面的，详尽的" class="headerlink" title="全面的，详尽的"></a>全面的，详尽的</h5><p>comprehensive = exhaustive = inclusive</p><h5 id="根据，就…而言"><a href="#根据，就…而言" class="headerlink" title="根据，就…而言"></a>根据，就…而言</h5><p>in matter of = in terms of = on the part of  = against</p><h5 id="好斗的"><a href="#好斗的" class="headerlink" title="好斗的"></a>好斗的</h5><p>pugnacious</p><h5 id="深奥难懂的"><a href="#深奥难懂的" class="headerlink" title="深奥难懂的"></a>深奥难懂的</h5><p>esotric = elusive = slippery = abstruse = impenetrable =opaque =dense</p><h5 id="阻止"><a href="#阻止" class="headerlink" title="阻止"></a>阻止</h5><p>hinder = stymie =obstruct = hamper =impede</p><h6 id="声称"><a href="#声称" class="headerlink" title="声称"></a>声称</h6><p>proclaim，profess，assert，maintain，aver ，purport</p><h5 id="掩盖"><a href="#掩盖" class="headerlink" title="掩盖"></a>掩盖</h5><p>belie= mask = veil =dissemble =cloak</p><h5 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h5><p>accentuate =highlight = underscore= foreground</p><h5 id="根深蒂固的"><a href="#根深蒂固的" class="headerlink" title="根深蒂固的"></a>根深蒂固的</h5><p>inveterate= entrenched= ingrained</p><h5 id="拒绝，放弃"><a href="#拒绝，放弃" class="headerlink" title="拒绝，放弃"></a>拒绝，放弃</h5><p>recant= repudiate =renounce = abnegate =disavow</p><h5 id="万能药"><a href="#万能药" class="headerlink" title="万能药"></a>万能药</h5><p>panacea= cure-all =nostrum</p><h5 id="不合理的，站不住脚的"><a href="#不合理的，站不住脚的" class="headerlink" title="不合理的，站不住脚的"></a>不合理的，站不住脚的</h5><p>tenuous=unsound=unfounded=unjustified=untenable=unwarranted=groundless=baseless</p><h5 id="矛盾的，不一致的"><a href="#矛盾的，不一致的" class="headerlink" title="矛盾的，不一致的"></a>矛盾的，不一致的</h5><p>competing=mixed=inconsistent</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;GRE填空常见观点&quot;&gt;&lt;a href=&quot;#GRE填空常见观点&quot; class=&quot;headerlink&quot; title=&quot;GRE填空常见观点&quot;&gt;&lt;/a&gt;GRE填空常见观点&lt;/h4&gt;&lt;p&gt;(1). 科学实验要客观，公正，可重复，可更正&lt;br&gt;(2). 专利法没有促进创新&lt;br&gt;(3). 物种入侵的危害不大/被夸大&lt;br&gt;(4). 工会(labor union)与资本家(business owner/ management)为敌对关系&lt;/p&gt;
    
    </summary>
    
    
      <category term="GRE" scheme="http://albuswhite.github.io/blog/categories/GRE/"/>
    
    
      <category term="GRE" scheme="http://albuswhite.github.io/blog/tags/GRE/"/>
    
  </entry>
  
  <entry>
    <title>Recent</title>
    <link href="http://albuswhite.github.io/blog/2019/10/30/recent/"/>
    <id>http://albuswhite.github.io/blog/2019/10/30/recent/</id>
    <published>2019-10-30T06:15:11.351Z</published>
    <updated>2019-10-30T06:15:11.351Z</updated>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="Hey, password is required here." />    <label for="hbePass">Hey, password is required here.</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="529b8845b43387b4ff9fc16ea9693b995fffda98795fbd94efff4b0897aac93e">5000957d6e1b9f1e1aefeb5b06572c83340c50114f95652081ccc155dbfbd3910b07fa60429a8554c5cd294a245965169a021785cc4bbb6194b9aaa71a8826801e08a887634a40493d105a31451ecbfb8b0d0160f34ea90d3fdcb21ee97d94b13014cd7834e350a31efb456f9a6db808911815252e460ed949ba161fa967041ee17687bd59cbb0385f54dfa409e4c4a849792ff02506245b9d6e09a33f6710e03bd2b55d58a43d91c4cf1c10e90767b67d22cee010b524639fbd867c34673e88ccf904c2832c45b0b955e629f79bcbd3ac3c7a7c2ae59b2633c92892167c6fb3dfed57a0f6d0ca15863d0d9209c4020359549c036f11040acef1d8228cc479d8bdae1b3f80b006f702a8d6099100fb365cbe7c5770dfd311c565393c3feb0b30a90342b72d7b5fed2212795e4bcb3a681b3a6f5178490c398db329cfe0fda642d299b579996824c5cc93217737fb800162eb9e9f6261bdeb3e5f82a196004ee5951a49a89182c030f47f111f01feeda05ad8fc604a7b4ad61c89f4d1ca28cff3b9b06d6ef98e6be6d05892bcff459ff9fe8f3be6ce53ccb3234b64773110432d834f27dc788c9e5a64b148e74d1125229d56ea4e86fd9d9d1c04855220e279edc09dc2063cca3c5a8fca7fd94a498441abe4202bd243f76980a519bee0503e62a59707929c97c75d8dd9f91c7d9ebfec2cbf87f02687bebe9068c06e941153ad2bc767ebb740434d597aeac5daa64b9062a8fee6ccfb44c2ad6c6d1757e3237ae92e601b50769c7af64867df826a0569226f6cb9b03697c7483daa9bb02b00126baeadc41aa5435168ce4fb7e8b8c5f51ced7cba9790ef6ebed2807c21a04ae853df33013f6b09120e045aacf55fb97553e89ad5efcb9d37de479c2479f672d975cc09ce37891d1437e4c83ddfb49afd19a95503ef0bd0e55c3da633559180e4d2245a1838fd09d34749d929ed6a2a4d0360a34762f30e9780fdc95970f01b78b35d6bee7fbdbf11020f02cd606ee2d8516fcd54254382045d4915c458650ac279e98c25b8f34197fd9bcf7e633ef20bb153faa14a14eea77959531c10bb7f82e1dbbb3021e14ca57a061b853265aedf</script></div><script src="/blog/lib/blog-encrypt.js"></script><link href="/blog/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      Here&#39;s something encrypted, password is required to continue reading.
    
    </summary>
    
    
      <category term="daily" scheme="http://albuswhite.github.io/blog/categories/daily/"/>
    
    
      <category term="daily" scheme="http://albuswhite.github.io/blog/tags/daily/"/>
    
  </entry>
  
  <entry>
    <title>Java Socket</title>
    <link href="http://albuswhite.github.io/blog/2019/10/30/Java%20Socket/"/>
    <id>http://albuswhite.github.io/blog/2019/10/30/Java Socket/</id>
    <published>2019-10-30T03:23:05.185Z</published>
    <updated>2019-10-30T03:23:05.185Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h2><p>端口,IP之类这里就不讲了.小学期大家都做过.<br>接下来说的都会按照课件最后一个多线程demo来讲<br> <a id="more"></a></p><h3 id="Socket的通信地址"><a href="#Socket的通信地址" class="headerlink" title="Socket的通信地址"></a>Socket的通信地址</h3><p>InetAddress是java封装好的函数,主要可以用作获取ip,用户名等.<br>e.g:<br><code>InetAddress address = InetAddress.getLocalHost();</code><br><code>System.out.println( address.getHostName());          //本机用户名</code><br><code>System.out.println( address.getHostAddress());       //本机ip</code></p><p>这里用了null, 那就会获取默认的 localhost/127.0.0.1<br><code>InetAddress addr = InetAddress.getByName(null)</code></p><h3 id="Socket通信过程"><a href="#Socket通信过程" class="headerlink" title="Socket通信过程"></a>Socket通信过程</h3><p><img src="http://blog.albuswhite.com.cn/socket%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%9E%8B.png" alt="Socket通信模型"></p><ol><li>创建ServerSocket和Socket</li><li>打开连接到Socket的输入/输出流</li><li>按照协议对Socket进行读/写操作</li><li>关闭输入输出流,关闭Socket</li></ol><h4 id="Sever端"><a href="#Sever端" class="headerlink" title="Sever端"></a>Sever端</h4><ol><li>创建ServerSocket对象,绑定监听端口</li></ol><p><code>ServerSocket s = new ServerSocket(PORT);</code></p><ol start="2"><li>通过accept( )方法监听客户端请求</li></ol><p><code>Socket socket = s.accept();</code></p><ol start="3"><li>连接建立后,通过输入流读取客户端发送的请求信息</li></ol><p><code>in = new BufferedReader(new InputStreamReader(socket.getInputStream()));</code><br><code>String str = in.readLine();</code><br>  注: BufferReader是缓冲读取</p><ol start="4"><li>通过输出流向客户端发送相映信息</li></ol><p><code>out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(socket.getOutputStream())), true);</code><br><code>out.println(str);     // 在输出流中写入数据</code></p><ol start="5"><li>关闭相关资源</li></ol><p><code>socket.close();</code></p><h4 id="Client端"><a href="#Client端" class="headerlink" title="Client端"></a>Client端</h4><ol><li><p>创建Socket对象,指明需要连接的服务器的地址和端口</p><p><code>socket = new Socket(addr, PORT);</code></p></li><li><p>连接建立后,通过输出流向服务器端发送请求信息</p><p><code>out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(socket.getOutputStream())), true);</code><br>注: 这个true是自动清空缓冲区的意思 </p><p><code>out.println(&quot;Client &quot; + id + &quot;: &quot; + i);</code></p></li></ol><ol start="3"><li><p>通过输入流获取服务器响应的信息</p><p><code>in = new BufferedReader(new InputStreamReader(socket.getInputStream())) ;</code><br><code>String str = in.readLine();     //读取响应信息</code></p></li><li><p>关闭相关资源</p><p><code>socket.close();</code></p></li></ol><h4 id="多线程实现多客户端"><a href="#多线程实现多客户端" class="headerlink" title="多线程实现多客户端"></a>多线程实现多客户端</h4><ol><li>服务器创建ServerSocket, 循环调用accept( )等待客户端连接</li><li>客户端创建一个socket并请求和服务器端连接</li><li>服务器端接受客户端请求,创建socket与该客户建立专线联系</li><li>建立连接的两个socket在一个单独的线程上对话</li><li>服务器端继续等待新的连接</li></ol><p>具体代码解释我就不写了,本质就是客户端多线程.<br>demo代码利用了Client的多线程模拟多个客户连接服务端, 服务端用多线程实现了多个连接</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Socket&quot;&gt;&lt;a href=&quot;#Socket&quot; class=&quot;headerlink&quot; title=&quot;Socket&quot;&gt;&lt;/a&gt;Socket&lt;/h2&gt;&lt;p&gt;端口,IP之类这里就不讲了.小学期大家都做过.&lt;br&gt;接下来说的都会按照课件最后一个多线程demo来讲&lt;br&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://albuswhite.github.io/blog/categories/Java/"/>
    
    
      <category term="Java" scheme="http://albuswhite.github.io/blog/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Words</title>
    <link href="http://albuswhite.github.io/blog/2019/10/15/Words/"/>
    <id>http://albuswhite.github.io/blog/2019/10/15/Words/</id>
    <published>2019-10-15T15:38:55.864Z</published>
    <updated>2019-10-15T15:38:55.864Z</updated>
    
    <content type="html"><![CDATA[<ol><li>elephantine 巨大的</li><li>ubiquity 笨拙的，无所不在的</li><li>promise 前途，预示</li><li>gainsay 否定，反驳</li><li>sterling 高质量的</li><li>ad hoc 特别的</li><li>anonymous 匿名的 不出名的</li><li>evenhanded 公平的</li><li>confessional 自白的</li><li>amplify 详细阐述，夸大<a id="more"></a></li><li>particularize 详细阐述</li><li>encase 围绕</li><li>fleeting 短暂的</li><li>incompatible 不可兼容的</li><li>cluster 堆</li><li>stratify 分层级的</li><li>innocuous 无害的，平淡的</li><li>overture 序曲</li><li>bleak 暗淡的</li><li>belie 掩饰，证明。。虚假</li><li>undercut 削弱</li><li>prefigure 预示</li><li>entail 包含</li><li>coincident 一致的，同时发生的</li><li>hack 砍</li><li>generic 通用的，普通的</li><li>inclusive 广泛的</li><li>proprietary 私有的</li><li>impenetrable 难懂的， 无法穿透的，冷漠麻木的</li><li>didactic 过分说教的</li><li>paradox 矛盾</li><li>cosmopolitan 世界性的，国际的</li><li>capricious 变化多端的</li><li>mercenary 唯利是图的</li><li>intransigent 不让步的</li><li>scathing 尖酸刻薄的</li><li>satirize 讽刺，挖苦</li><li>abhor 厌恶</li><li>relish 享受</li><li>enchanting 迷人的</li><li>flout 蔑视的</li><li>subvert 颠覆，破坏</li><li>palpable 可感知的，明显的</li><li>temperate 温和的</li><li>delegates 委托于</li><li>ascribe 归因于</li><li>sophisticated 复杂的，富有经验的</li><li>consensus 意见一致的</li><li>compunction 后悔感</li><li>dichotomy 矛盾</li><li>untenable 站不住脚的</li><li>bypass 绕过</li><li>magnify 放大</li><li>circumvent 绕过</li><li>evanescent                                         短暂的</li><li>demise 死亡</li><li>transient 短暂的</li><li>decay 衰退</li><li>deteriorate 恶化</li><li>conspicuous 明显的</li><li>intriguing 非常有趣的</li><li>trifling 不重要的</li><li>deleterious 有害的</li><li>deceptive 欺骗性的</li><li>plastic 可以适应的</li><li>potency 能力，权力</li><li>encumber 阻碍</li><li>replete 充满的</li><li>discretionary 自由决定的</li><li>bureaucracy 管理机构</li><li>skirt 回避</li><li>scrutinize 详细检查</li><li>counter 反驳</li><li>revelation 揭露</li><li>stigma 污点</li><li>allure 引诱</li><li>blemish 玷污</li><li>inveterate 一贯的</li><li>intercept 拦截</li><li>oblige 迫使</li><li>suffocate 阻碍</li><li>monitor 监控</li><li>commend 称赞</li><li>weird 奇怪的</li><li>shackle 阻碍</li><li>admonish 警告</li><li>hazardous 危险的</li><li>momentous 重要的</li><li>precarious 处境危险的</li><li>stagnate 停滞</li><li>rigid 僵硬的</li><li>repudiate 否认</li><li>recant 否认</li><li>neural 中立的</li><li>betray 背叛</li><li>expel 驱逐</li><li>endorse 公开支持</li><li>oust 驱逐</li><li>sanction 支持</li><li>discrete 离散的</li><li>irascibility 易怒的</li><li>confused 混乱的</li><li>perfunctory 不走心的</li><li>overt 明显的</li><li>exacting 要求高的，费力的</li><li>ballyhoo 大肆宣传</li><li>quip 机智幽默的评论</li><li>pensive 思考的</li><li>droll 古怪的</li><li>stoicism 淡泊</li><li>hectic 非常忙碌分</li><li>demanding 费力的</li><li>dilatory 拖拉的</li><li>averse 反感的</li><li>empiricism 基于观察和实验</li><li>utilitarian 实用的，功利的</li><li>parochial 狭隘的</li><li>irk 使…厌烦</li><li>flippancy 轻率无礼</li><li>subtle 灵巧的</li><li>discursive 经推论而得的</li><li>sabotage 破坏</li><li>acquiesce 默许</li><li>intractable 难驾驭的</li><li>veneration 尊敬</li><li>detestation 憎恶</li><li>grant  承认，授予，允许</li><li>obsequious 谄媚的</li><li>discreet 谨慎的</li><li>refute 反驳</li><li>defy 不遵守</li><li>rosy 乐观的</li><li>encomium 赞美</li><li>tribute 赞美</li><li>nullify 使无效</li><li>daunting 难以处理</li><li>placid 平静的</li><li>forbidding 阻挠的</li><li>taxing 繁重的，劳累的</li><li>circumscribe 限制</li><li>onerous 繁重的</li><li>multifarious 各种各种的</li><li>confine 限制</li><li>proscribe 禁止</li><li>inhibit 抑制</li><li>supersede 淘汰</li><li>hinder 阻碍</li><li>taint 败坏，污染</li><li>profound 深刻的</li><li>marginal       边缘的</li><li>absurd          荒谬的</li><li>apt               合适的，有倾向的，聪明的</li><li>anchor 使…稳定</li><li>tenuous 薄弱的</li><li>outrage 使…生气</li><li>captives 吸引</li><li>cynical  怀疑他人动机不纯的</li><li>provocative   引起争论的/思考的</li><li>fray 使紧张，急躁</li><li>bewilder 使..困惑</li><li>assault 攻击</li><li>lucid 清晰的，透明的</li><li>volatile 性格多变的</li><li>forbear 克制，忍耐</li><li>authorization 独裁主义的</li><li>contentious 引起争议的，爱争吵的</li><li>paradigm 典范</li><li>mercenary 唯利是图的</li><li>compelling 有趣的，有说服力的</li><li>esoteric   难懂的</li><li>pedestrian  平凡普通的</li><li>speculation 猜测</li><li>extraneous 无关的</li><li>demonstrable  可证明的</li><li>transcendent 超然的，卓然的</li><li>aver  声称</li><li>feign 假装，伪装</li><li>avow  承认</li><li>lopsided 不均衡的</li><li>feeble 衰弱的</li><li>robust 强壮的</li><li>turbulent 混乱的</li><li>lethargic 漠不关心的</li><li>fervor 热情</li><li>hybrid 混合物</li><li>indiscriminate 不加区分的</li><li>conciliate 安慰</li><li>exhaustive 全面</li><li>glib 油嘴滑舌的</li><li>veracious 真实的</li><li>vivacious 活力四射的</li><li>substantial 大量的</li><li>prestigious 有声望的</li><li>anomalous 异常的</li><li>affinity 倾向，偏好，密切关系</li><li>objection 反对</li><li>opaque  难懂的</li><li>pugnacious 好争斗的</li><li>deliberate 深思熟虑</li><li>punctilious 谨慎小心的</li><li>courteous 有礼貌的</li><li>complacent 自我感觉良好的</li><li>truculent 好争斗的</li><li>myraid 大量</li><li>attest 证明</li><li>heterogeneous 组成多样的</li><li>indeterminate 不确定的</li><li>champion 支持</li><li>downplay 轻视</li><li>mercurial 任性多变的</li><li>phlegmatic 冷漠的</li><li>apathetic  漠不关心的</li><li>cunning  狡猾机智的</li><li>blithe 快乐的</li><li>authoritarian 独裁的</li><li>histrionic 不自然的</li><li>megalomania 自大狂</li><li>egalitarian 平等的</li><li>indolent 懒惰的</li><li>charismatic 有魅力的</li><li>prognosis 预测</li><li>auspicious 吉祥的</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;elephantine 巨大的&lt;/li&gt;
&lt;li&gt;ubiquity 笨拙的，无所不在的&lt;/li&gt;
&lt;li&gt;promise 前途，预示&lt;/li&gt;
&lt;li&gt;gainsay 否定，反驳&lt;/li&gt;
&lt;li&gt;sterling 高质量的&lt;/li&gt;
&lt;li&gt;ad hoc 特别的&lt;/li&gt;
&lt;li&gt;anonymous 匿名的 不出名的&lt;/li&gt;
&lt;li&gt;evenhanded 公平的&lt;/li&gt;
&lt;li&gt;confessional 自白的&lt;/li&gt;
&lt;li&gt;amplify 详细阐述，夸大
    
    </summary>
    
    
      <category term="GRE" scheme="http://albuswhite.github.io/blog/categories/GRE/"/>
    
    
      <category term="GRE" scheme="http://albuswhite.github.io/blog/tags/GRE/"/>
    
  </entry>
  
  <entry>
    <title>Verbal2</title>
    <link href="http://albuswhite.github.io/blog/2019/10/10/Verbal2/"/>
    <id>http://albuswhite.github.io/blog/2019/10/10/Verbal2/</id>
    <published>2019-10-10T09:57:32.464Z</published>
    <updated>2019-10-10T09:57:32.464Z</updated>
    
    <content type="html"><![CDATA[<h4 id="类比题"><a href="#类比题" class="headerlink" title="类比题"></a>类比题</h4><p>Which of the following situations is mostly analogous/simialr to the situation described by the author</p><h4 id="词组例句"><a href="#词组例句" class="headerlink" title="词组例句"></a>词组例句</h4><p>credit A with B                  把B归到A身上<br>could hardly help doing    情不自禁地</p> <a id="more"></a><ol><li>可能猴子产生了更高的皮质醇是因为出生顺序的影响，但是作者的论证不是特别有说服力。</li></ol><p>While it may be true that birth order might make effect on cortisol level, the author’s argument does not make a cogent case for the correlation</p><ol start="2"><li>可能 p 这个地方确实没有船，但是作者的论证不是特别有说服力。</li></ol><p>While it may be true that there is no boat in p, the author does not make a cogent case  in the line of reasoning </p><ol start="3"><li>我们不清楚 Grove college 学生是否都说了实话。</li></ol><p>It’s not clear, however, whether Grove college student hide the truth or not.</p><ol start="4"><li><p>引用 workby 医院的报告，作者表明 ultra clean 洗手液抑菌效果好</p><p>Citing reports of hospital in workby, the author demostrate that ultra clean solution is superior in anti-bacteria effect</p></li><li><p>引用 Grove college 学生的调查，作者暗示 honor code 能有效减少作弊。</p></li></ol><p>Citing survey of Grove college students, the author demostrate that honor code can effectively reduce cheating </p><p>Page 94, 96, 90, 82 </p><h4 id="范文"><a href="#范文" class="headerlink" title="范文"></a>范文</h4><p>In this argument, the author recommends that Monarch books should open up a cafe. (conclusion) In order to support her conclusion, she uses the following evidence : first, Monarch, established there for twenty years, has large customer base; second, building upon a national<br>survey that populations of children under the age of ten have reduced drastically, the author suggests that children’s book seciton could be eliminated for alternative use; third, our competitor , Regal Book, has  recently set up a cafe (evidence) However, here argument is laden with crucial questions unanswered, and therefore, cannot effectively back the author’s claim(instruction)</p><p>(While it may be true that Monarch has large customer base, the author cannot effectively back his argument according to the achievement of the bookstore. Obviouly, the author presumes that those loyalty clients who patronize the books will surely go to the cafe. However, …<br>The mere fact that Monarch has large clients base could back the author’s cliam only if  those customer will frequent the cafe.)</p><p>Even if Monarch has large clients base(premise), it does not necessarily mean that opening up a cafe would achieve the same success(conclusion). Clearly, the author assumes that those clients who pastronize the books will surely go to the cafe if they land chances.(assumption) However, it might be possible  that those customers are so absorb in their books, hardly ever could they squeeze out time to have drinks; or perhaps they just do not like coffee at all, especially considering that the smell of such drink would spread their attention on books; or perhaps they just have their own preferred cafe, rather than frequenting the Monarch, all of if true might seriously undermine the article.  Hence, the author should better provide us evidence regarding that those clients will definiately go to the cafe on a regular basis, then we could stand a better position to evaluate the author’s whole position(specific evidence)</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;类比题&quot;&gt;&lt;a href=&quot;#类比题&quot; class=&quot;headerlink&quot; title=&quot;类比题&quot;&gt;&lt;/a&gt;类比题&lt;/h4&gt;&lt;p&gt;Which of the following situations is mostly analogous/simialr to the situation described by the author&lt;/p&gt;
&lt;h4 id=&quot;词组例句&quot;&gt;&lt;a href=&quot;#词组例句&quot; class=&quot;headerlink&quot; title=&quot;词组例句&quot;&gt;&lt;/a&gt;词组例句&lt;/h4&gt;&lt;p&gt;credit A with B                  把B归到A身上&lt;br&gt;could hardly help doing    情不自禁地&lt;/p&gt;
    
    </summary>
    
    
      <category term="GRE" scheme="http://albuswhite.github.io/blog/categories/GRE/"/>
    
    
      <category term="GRE" scheme="http://albuswhite.github.io/blog/tags/GRE/"/>
    
  </entry>
  
</feed>
